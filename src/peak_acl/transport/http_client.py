# MIT License
# Copyright (c) 2025 Santiago Bossa
# See LICENSE file in the project root for full license text.

"""
Asynchronous FIPA HTTP-MTP client.

This client packages an ACL message + transport envelope into a
``multipart/mixed`` body and POSTs it to a remote ACC (Agent Communication
Channel). It implements exponential backoff with jitter and reuses a single
``aiohttp.ClientSession`` for efficiency.

Public API
----------
- :class:`HttpMtpClient`
- :class:`HttpMtpError`
"""

from __future__ import annotations

import asyncio
import logging
import random
from typing import Optional

import aiohttp
from aiohttp import ClientTimeout

from ..message.aid import AgentIdentifier
from ..message.acl import AclMessage
from .multipart import build_multipart

__all__ = ["HttpMtpClient", "HttpMtpError"]

log = logging.getLogger("peak_acl.http_mtp_client")


# --------------------------------------------------------------------------- #
# Errors
# --------------------------------------------------------------------------- #
class HttpMtpError(RuntimeError):
    """Definitive failure while sending a message to the ACC."""


# --------------------------------------------------------------------------- #
# HttpMtpClient
# --------------------------------------------------------------------------- #
class HttpMtpClient:
    """HTTP-MTP sender with retry/backoff support.

    Parameters
    ----------
    retries :
        Maximum number of attempts before giving up (default: 3).
    backoff_base :
        Initial backoff delay in seconds (default: 0.8).
    backoff_cap :
        Maximum backoff delay in seconds (default: 4.0).
    timeout :
        Per-request total timeout passed to ``aiohttp.ClientSession`` (seconds).
    session :
        Optional externally managed ``aiohttp.ClientSession``. If omitted, this
        class creates and owns one (and will close it on ``close()``).

    Notes
    -----
    * Jitter (~Â±30%) is applied to each backoff delay to avoid thundering herds.
    * Use as an async context manager to ensure the internal session is closed:

      .. code-block:: python

         async with HttpMtpClient() as client:
             await client.send(...)
    """

    def __init__(
        self,
        *,
        retries: int = 3,
        backoff_base: float = 0.8,
        backoff_cap: float = 4.0,
        timeout: float = 10.0,
        session: Optional[aiohttp.ClientSession] = None,
    ):
        self.retries = retries
        self.backoff_base = backoff_base
        self.backoff_cap = backoff_cap
        self._owns_session = session is None
        self.session = session or aiohttp.ClientSession(
            timeout=ClientTimeout(total=timeout)
        )

    # ------------------------------------------------------------------ #
    async def send(
        self,
        to_ai: AgentIdentifier,
        from_ai: AgentIdentifier,
        acl_msg: AclMessage,
        acc_url: str,
    ) -> None:
        """Send a single ACL message to the ACC via HTTP POST.

        Parameters
        ----------
        to_ai :
            Recipient agent identifier (envelope ``to``).
        from_ai :
            Sender agent identifier (envelope ``from``).
        acl_msg :
            ACL message to serialize and include as payload.
        acc_url :
            ACC endpoint URL (HTTP-MTP).

        Raises
        ------
        HttpMtpError
            If all retry attempts fail or a non-200 HTTP status is returned.

        Implementation details
        ----------------------
        * Body is generated by :func:`build_multipart`.
        * Exponential backoff with jitter is used between retries.
        * On non-200 responses, the first 256 chars of the body are included to
          aid debugging without flooding logs.
        """
        body, ctype = build_multipart(to_ai, from_ai, acl_msg)
        headers = {
            "Content-Type": ctype,
            "Cache-Control": "no-cache",
            "Mime-Version": "1.0",
        }

        attempt = 0
        delay = self.backoff_base
        while True:
            try:
                async with self.session.post(acc_url, data=body, headers=headers) as resp:
                    if resp.status == 200:
                        log.info("Sent to %s (status 200)", acc_url)
                        return
                    text = (await resp.text())[:256]
                    raise HttpMtpError(f"ACC returned {resp.status}: {text}")

            except (aiohttp.ClientError, asyncio.TimeoutError) as exc:
                attempt += 1
                if attempt > self.retries:
                    raise HttpMtpError(
                        f"Failed after {self.retries} attempts: {exc}"
                    ) from exc

                jitter = random.uniform(0, 0.3 * delay)
                log.warning(
                    "Attempt %d failed (%s); retrying in %.1fs",
                    attempt,
                    exc,
                    delay + jitter,
                )
                await asyncio.sleep(delay + jitter)
                delay = min(delay * 2, self.backoff_cap)

    # ------------------------------------------------------------------ #
    async def close(self) -> None:
        """Close the owned ``ClientSession`` if it was created internally."""
        if self._owns_session and not self.session.closed:
            await self.session.close()

    # ------------------------------------------------------------------ #
    # Async context manager helpers
    # ------------------------------------------------------------------ #
    async def __aenter__(self):
        """Return self to support ``async with`` usage."""
        return self

    async def __aexit__(self, *exc):
        """Ensure ``close()`` is called when leaving the async context."""
        await self.close()
